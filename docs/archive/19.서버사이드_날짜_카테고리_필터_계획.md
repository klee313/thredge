# 서버사이드 날짜/카테고리 필터 도입 계획

## 배경/문제
- 현재 날짜/카테고리 필터가 프론트엔드에서 클라이언트 사이드로만 동작한다.
- 페이징 도입 이후 클라이언트가 로드한 일부 데이터만 필터링하여 기대와 다른 결과를 반환한다.
- 사용자가 날짜 또는 카테고리로 필터링할 때 전체 데이터가 아닌 현재 페이지 데이터만 대상이 되어 정확도가 떨어진다.

## 목표
- 백엔드 feed API에 날짜/카테고리 필터 파라미터를 추가하여 서버 측에서 필터링한다.
- 프론트엔드가 필터 조건을 서버에 전달하고 정확한 필터 결과를 받을 수 있도록 한다.
- 기존 페이징 동작과 호환을 유지하면서 필터 기능을 확장한다.

## 범위
- 포함
  - `GET /api/threads/feed`에 `date`, `categoryIds` 쿼리 파라미터 추가
  - ThreadRepository에 필터링 쿼리 추가
  - ThreadService에서 파라미터에 따른 분기 처리
  - 프론트엔드 API 함수 및 훅에서 필터 파라미터 전달
  - 기존 클라이언트 필터 로직 제거 또는 서버 필터로 대체
- 제외
  - 검색(`/api/threads/search`) 필터링은 별도 과제로 분리
  - 숨김 목록(`/api/threads/hidden`) 필터링은 별도 과제로 분리

## 현재 동작 정리
- ThreadController의 `feed` 엔드포인트는 `page`, `size` 파라미터만 받는다.
- ThreadRepository의 `findByOwnerUsernameAndIsHiddenFalseOrderByIsPinnedDescLastActivityAtDesc`는 날짜/카테고리 조건이 없다.
- HomeFeed.tsx에서 `filteredThreads`가 클라이언트 측에서 날짜/카테고리로 필터링한다.
- CategoryFilterBar에서 선택된 카테고리, DateFilter에서 선택된 날짜를 상태로 관리한다.

## 개선 방향
- 백엔드: 새 쿼리 메서드 또는 동적 쿼리(Specification/QueryDSL)로 필터 조건 처리
- 프론트엔드: 기존 useInfiniteQuery에서 필터 값을 queryKey에 포함하고 API에 전달
- 클라이언트 필터 로직은 서버 결과에 의존하도록 단순화

## 단계별 계획

### Step 1: 백엔드 - API 파라미터 추가
- ThreadController의 `feed` 메서드에 `date`(LocalDate, optional), `categoryIds`(List<String>, optional) 파라미터 추가
- 파라미터 검증(날짜 형식, 카테고리 ID 유효성) 추가
- 완료 기준: 컴파일 성공, 기존 동작 유지(파라미터 없이 호출 시 기존과 동일)

### Step 2: 백엔드 - Repository 필터 쿼리 구현
- ThreadRepository에 JPQL 쿼리 추가: 날짜/카테고리 조건 포함
  - 날짜 필터: `t.createdAt` 또는 해당 날짜 범위 조건
  - 카테고리 필터: `t.categories.id in :categoryIds` 또는 uncategorized 조건
- 선택지: Specification 패턴 또는 추가 쿼리 메서드
- 완료 기준: 단위 테스트 또는 통합 테스트로 필터 결과 검증

### Step 3: 백엔드 - Service 연결
- ThreadService의 `feed` 메서드에서 필터 파라미터에 따라 적절한 repository 호출
- 파라미터가 없을 때 기존 로직 유지
- 완료 기준: API 호출로 필터 동작 확인

### Step 4: 프론트엔드 - API 함수 수정
- `fetchThreadFeedPage`에 `date`, `categoryIds` 옵션 파라미터 추가
- URL 쿼리스트링에 필터 값 포함
- 완료 기준: 네트워크 요청에서 파라미터 확인

### Step 5: 프론트엔드 - 훅 및 컴포넌트 수정
- HomeFeed의 `useInfiniteQuery` queryKey에 날짜/카테고리 포함
- 서버 필터 결과 사용, 클라이언트 필터 로직 제거
- 카테고리/날짜 변경 시 쿼리 리셋
- 완료 기준: 필터 선택 시 올바른 데이터 표시

### Step 6: 검증 및 정리
- 수동 테스트: 홈 화면에서 날짜/카테고리 필터 동작 확인
- 기존 동작 회귀 확인
- 불필요한 클라이언트 필터 코드 정리
- 완료 기준: 전체 필터 흐름 정상 동작

## 리스크 및 대응
- 복잡한 필터 조합으로 쿼리 성능 저하 가능
  - 대응: 적절한 인덱스 확인, 초기 단순 필터로 시작
- 날짜 필터 기준(createdAt vs lastActivityAt) 혼란 가능
  - 대응: 명확히 createdAt 기준으로 정의하고 문서화
- 프론트 queryKey 변경으로 기존 캐시 무효화
  - 대응: 필터 변경 시 명시적 리셋 처리

## 검증 계획

### 통합 테스트 (권장)
- `BackendApplicationTests`를 확장하거나 새 테스트 클래스 추가
- 테스트 실행 명령:
```bash
cd /Users/gang-ug/workspace/thredge/backend
./gradlew test
```

### 수동 테스트
1. 백엔드 서버 실행:
```bash
cd /Users/gang-ug/workspace/thredge/backend
./gradlew bootRun
```
2. 프론트엔드 개발 서버 실행:
```bash
cd /Users/gang-ug/workspace/thredge/frontend
npm run dev
```
3. 브라우저에서 홈 화면 접속 후:
   - 카테고리 필터 선택 → 해당 카테고리 쓰레드만 표시되는지 확인
   - 날짜 필터 선택 → 해당 날짜 생성 쓰레드만 표시되는지 확인
   - Load more 클릭 → 필터가 유지되면서 추가 데이터 로드 확인
   - 필터 해제 → 전체 데이터로 복귀 확인
