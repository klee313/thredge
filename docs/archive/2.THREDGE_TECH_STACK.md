# thredge 기술 스택/아키텍처 제안

## 1) 전제 및 원칙
- 프론트엔드: React 기반
- 백엔드: **Kotlin + Spring** 기반, **JPA 사용**
- 로컬 실행: 프론트/백엔드 모두 Docker 컨테이너로 구동
- CI: GitHub Actions로 빌드 파이프라인 구성
- AI 기능(테스트/대화/교정/뉴스 단순화/글쓰기 평가)은 “교정 설정 가능”, “근거 확인 가능”, “안전 가드레일”을 기본 원칙으로 둔다.
- 다국어 확장 필수: 최소 **한국어/영어/터키어** 지원(앱 UI 언어 + 학습 언어)

## 2) 저장소 구조(모노레포 권장)
- `frontend/`: React 앱
- `backend/`: Kotlin/Spring Boot API 서버
- `infra/`: 로컬/CI용 인프라(Dockerfile, compose, 스크립트)
- `docs/`: 제품/설계/운영 문서
  - `docs/archive/`: 큰 작업 단위 계획 문서(순번 파일)

## 3) 프론트엔드(React) 기술 스택
> `klee313/flight-number-searcher`의 README에 기재된 스택을 기본 참조로 삼는다.

### 3.1 Core
- React 19 + TypeScript
- Vite 7

### 3.2 Routing / Server State / UI State
- React Router v7
- TanStack Query v5(React Query)
- Zustand(전역 UI 상태: 모달, 토스트, 설정 등)

### 3.3 Form / Validation
- React Hook Form
- Zod(런타임 스키마/검증)

### 3.4 UI / Styling / Icons
- Tailwind CSS
- shadcn/ui(Radix 기반)
- lucide-react(아이콘)

### 3.5 i18n / Date
- react-i18next + i18next-browser-languagedetector
- date-fns

#### 기본 지원 언어(초기 목표)
- UI 언어(locale): `ko`, `en`, `tr`
- 학습 언어(targetLanguage): `ko`, `en`, `tr` (**MVP부터 3개를 학습 언어로 지원**)
- 모국어(nativeLanguage): 우선 `ko`, `en`, `tr` 지원(테스트/설명 언어로 사용)

### 3.6 음성(대화/과제)
- MVP(브라우저 우선)
  - 입력(STT): Web Speech API(지원 브라우저 한정) 또는 녹음 파일 업로드
  - 출력(TTS): Web Speech Synthesis API(지원 브라우저 한정)
- 확장(정확도/일관성 우선)
  - 서버 경유 STT/TTS(외부 프로바이더) + 비용/지연 관리(캐싱/비동기)

### 3.7 대화/교정 UX 구현 포인트
- 대화 중 팝업: 특정 발화/문장에 대해 “틀린 표현”과 “자연스러운 대안”을 하이라이트
- 교정 정책: 설정(ON/OFF, 강도)에 따라 UI 흐름이 달라지도록 설계
  - 즉시 교정 모드: 메시지 단위로 피드백 표시
  - 지연 교정 모드: 세션 종료 후 “요약 리포트” 제공

## 4) 백엔드(Spring) 기술 스택

### 4.1 Core
- Spring Boot(최신 LTS 계열) + Kotlin(최신 안정 버전) + JDK 21 권장
- Gradle(빌드, Kotlin DSL 권장)
- Spring Web(REST API)
- Spring Validation(요청 검증)
- Spring Security(인증/인가)
- OpenAPI 문서화(springdoc-openapi)

### 4.1.1 인증(우선순위: ID/PW, 확장: OAuth)
- 1차(MVP): ID/PW 기반 회원가입/로그인
  - 비밀번호: 단방향 해시(예: BCrypt)
  - 인증 방식: **세션 기반(stateful) 권장**
    - Spring Session JDBC + PostgreSQL로 세션을 저장(= Redis 없이도 확장 가능)
    - 쿠키 기반으로 웹(브라우저) 사용성을 단순화
- 2차(확장): OAuth 로그인/계정 연결
  - Spring Security OAuth2 Client를 통해 소셜 로그인을 추가 가능한 구조로 설계

### 4.2 데이터 접근(JPA)
- Spring Data JPA + Hibernate
- 스키마 마이그레이션은 Flyway로 관리(초기에는 세션 테이블은 Spring Session JDBC가 자동 생성 가능)

### 4.3 DB / 마이그레이션 / 캐시
- PostgreSQL(권장)
- Flyway(스키마 마이그레이션)
- Redis: MVP에서는 제외(필요성 생기면 캐시/레이트리밋/세션 보조 저장으로 추후 도입)

### 4.4 실시간/스트리밍(선택)
- WebSocket(SSE 포함)로 대화 진행 상태, 교정 결과, 코치 쪽지 알림 등을 푸시
- 음성 스트리밍은 MVP에선 제외하고, 이후 필요 시 WebRTC/스트리밍 STT로 확장

## 5) AI(LLM) 통합 설계

### 5.1 사용처(요구사항 매핑)
- ‘학습 성공’ 판별 테스트(요구사항 4): 대화형 테스트 + 채점/루브릭 기반 판정
- 익숙해지기 대화(요구사항 7): 자유 대화 + 교정(옵션) + 자연스러운 문장 제안
- 쪽지(요구사항 6,8): 격려/피드백/학습 주제 조정
- 뽐내기(요구사항 10): 뉴스 난이도 조정(요약/단순화), 글쓰기 평가

### 5.2 안전/정책(특히 “자극 메시지”)
- 사용자 설정 기반 톤(예: 따뜻함/담백함/엄격함) + 기본값은 “따뜻함”
- 금지 표현/모욕/혐오/위협 등은 정책으로 차단
- 사용자가 “엄격함”을 선택하더라도, 인신공격성 문구는 제한(서비스 정책)
- 모든 AI 출력은 프롬프트에 “설명 가능(왜 틀렸는지)”과 “사용자 레벨 고려”를 포함

### 5.3 프롬프트/루브릭 관리
- 프롬프트는 코드에 하드코딩하지 않고 템플릿/버전 관리(예: `backend/src/main/resources/prompts/`)
- 채점 루브릭은 “레벨별”로 분리(예: A1/A2는 의미 전달 중심, B2+는 자연스러움 가중치 상승)
- 회귀 테스트용 샘플(입력/기대 판정)을 축적해 일관성 점검

### 5.4 비용/지연 최적화
- 캐싱: 동일 문장 교정/뉴스 단순화 결과 캐싱(해시 키)
- 대화 로그 요약: 세션 종료 시만 요약 생성(옵션)
- 비동기 작업 큐(필요 시): 글쓰기 평가/긴 뉴스 단순화는 백그라운드 처리

### 5.5 벤더/모델 선택 여지(추상화)
- 목표: 특정 AI API에 종속되지 않도록, 백엔드에 “LLM Provider” 추상화를 둔다.
  - 예: `LLMClient`(chat, json-schema, embedding 등) 인터페이스 + 구현체(Provider A/B)
  - 환경변수로 provider/model을 선택하고, 운영 중 교체 가능하도록 설계
- 단어 풀 생성은 “콘텐츠 생성 파이프라인(배치/어드민)”으로 분리하고, 기본 모델은 GPT-5.2를 사용하되(요구사항), 호출 레이어는 동일 추상화를 재사용한다.

## 6) CEFR/콘텐츠 데이터(단어/문법/뉴스)

### 6.1 단어/문법 카탈로그
- 내부에 “레벨(CEFR) + 주제 태그 + 예문”을 갖는 카탈로그 테이블이 필요하다.
- 카탈로그/“다음 레벨 단어 풀”은 **GPT-5.2로 생성**하는 것을 기본으로 한다.
  - 생성 파이프라인(배치/어드민)에서 아래 메타데이터를 함께 저장한다.
    - 생성 프롬프트/버전, 모델/파라미터, 생성 시각, 생성 요청자, 검수 상태, 중복 그룹 키
  - 품질 기준(예)
    - 레벨 적합성(CEFR), 의미/예문 자연스러움, 금칙어/유해 표현 필터, 언어 코드 일관성
    - 표제어 정규화(소문자/품사/원형), 동형이의어 처리, 동의어 중복 제거

### 6.2 다음 레벨 대비 % 계산
- “다음 레벨 단어 풀”을 명확히 정의해야 한다.
  - 예: A2 사용자의 다음 레벨은 B1, B1 목표 단어 N개를 고정 목록으로 관리
  - 성공 단어 수 / N * 100 표시(정책은 `docs/`에 고정)

### 6.3 뉴스 난이도 조정
- 입력(원문) → 출력(레벨 조정문) 과정에서
  - 목표 레벨 어휘 제한
  - 어려운 단어는 쉬운 동의어/설명으로 대체
  - 문장 길이/구문 단순화
- 결과물에 “원문 보기/비교(옵션)” 제공 가능(초기엔 생략 가능)

## 7) 인프라(로컬/Docker/환경변수)
- Docker Compose로 아래 서비스를 묶어 로컬에서 1명 개발이 가능하도록 구성
  - `frontend`(Vite dev 또는 빌드된 정적 서빙)
  - `backend`(Spring Boot)
  - `db`(PostgreSQL)
  - `redis`(선택, MVP 제외)
- 환경변수
  - DB 접속, 세션/쿠키 관련 설정(도메인/secure/samesite 등), LLM API 키, STT/TTS 키(선택)
  - `.env.example`로 샘플 제공, 실제 키는 로컬 `.env` 또는 GitHub Secrets로 관리

## 8) CI(GitHub Actions) 제안
- PR/Push 트리거로 분리 실행
  - Frontend: `npm ci` → `lint` → `test`(있다면) → `build`
  - Backend: `./gradlew test` → `./gradlew build`
  - (선택) Docker 이미지 빌드 체크(푸시 없이 빌드만)
- 캐시
  - Node modules 캐시, Gradle 캐시
- 품질 게이트(초기 최소)
  - TypeScript typecheck, 기본 lint
  - 백엔드 테스트(단위/슬라이스) 최소

## 9) 테스트/검증 도구
- Backend
  - JUnit 5 + AssertJ(기본)
  - Testcontainers(PostgreSQL)로 통합 테스트 신뢰성 확보
  - WireMock/MockWebServer로 외부 AI API 모킹(비용/변동성 차단)
- Frontend
  - Vitest + Testing Library(권장)
  - 핵심 플로우는 Playwright E2E(선택, 단계적 도입)

## 10) 보안/개인정보/운영 고려(초기부터 최소 반영)
- 학습 대화 로그/쪽지/작문은 민감 데이터가 될 수 있음
  - 보관 기간/삭제 기능/내보내기 정책을 초기에 문서화
- 프롬프트 주입/유해 발화 대응
  - 시스템 프롬프트 고정, 사용자 입력 분리, 금칙어/정책 필터
- 레이트리밋/남용 방지
  - 인증 기반 요청 제한, 비용 폭주 방지(일일 한도/쿼터)
